worker_processes  1;
daemon on;
master_process off;
error_log /home/dou/work/svn/nginx_module/durap/t/servroot/logs/error.log debug;
pid       /home/dou/work/svn/nginx_module/durap/t/servroot/logs/nginx.pid;
env MOCKEAGAIN_VERBOSE;
env MOCKEAGAIN;
env MOCKEAGAIN_WRITE_TIMEOUT_PATTERN;
env LD_PRELOAD;
env DYLD_INSERT_LIBRARIES;
env LUA_PATH;
env LUA_CPATH;



http {
    access_log /home/dou/work/svn/nginx_module/durap/t/servroot/logs/access.log;
    #access_log off;

    default_type text/plain;
    keepalive_timeout  68;


    resolver 8.8.8.8;


    server {
        listen          1984;
        server_name     'localhost';

        client_max_body_size 30M;
        #client_body_buffer_size 4k;

        # Begin preamble config...

        # End preamble config...

        # Begin test case config...
    location /t {
        content_by_lua '
            local cjson = require "cjson"

            local mysql = require "resty.mysql"
            local db = mysql:new()

            db:set_timeout(2000) -- 2 sec

            local ok, err, errno, sqlstate = db:connect({
                host = "127.0.0.1",
                port = 3306,
                database = "ngx_test",
                user = "ngx_test",
                password = "ngx_test"})

            if not ok then
                ngx.say("failed to connect: ", err, ": ", errno, " ", sqlstate)
                return
            end

            ngx.say("connected to mysql.")

            local res, err, errno, sqlstate = db:query("drop table if exists cats")
            if not res then
                ngx.say("bad result: ", err, ": ", errno, ": ", sqlstate, ".")
                return
            end

            ngx.say("table cats dropped.")

            res, err, errno, sqlstate = db:query("create table cats (id serial primary key, name varchar(1024))")
            if not res then
                ngx.say("bad result: ", err, ": ", errno, ": ", sqlstate, ".")
                return
            end

            ngx.say("table cats created.")

            res, err, errno, sqlstate = db:query("insert into cats (name) value (\'"
                   .. string.rep("B", 1024)
                   .. "\')")

            if not res then
                ngx.say("bad result: ", err, ": ", errno, ": ", sqlstate, ".")
                return
            end

            ngx.say(res.affected_rows, " rows inserted into table cats (last id: ", res.insert_id, ")")

            res, err, errno, sqlstate = db:query("select * from cats order by id asc")
            if not res then
                ngx.say("bad result: ", err, ": ", errno, ": ", sqlstate, ".")
                return
            end

            ngx.say("result: ", cjson.encode(res))

            res, err, errno, sqlstate = db:query("select * from cats order by id desc")
            if not res then
                ngx.say("bad result: ", err, ": ", errno, ": ", sqlstate, ".")
                return
            end

            ngx.say("result: ", cjson.encode(res))

            local ok, err = db:close()
            if not ok then
                ngx.say("failed to close: ", err)
                return
            end
        ';
    }

        # End test case config.

        location / {
            root /home/dou/work/svn/nginx_module/durap/t/servroot/html;
            index index.html index.htm;
        }
    }
}

#timer_resolution 100ms;

events {
    #accept_mutex off;

    worker_connections  64;
}
